#include "core/node_template_registry.h"
#include <iostream>

// Node type metadata registry - automatically imported from SDK node types
// This maps node types to their metadata (category, required/optional params,
// etc.)
const std::map<std::string, NodeTemplateRegistry::NodeTypeMetadata>
    NodeTemplateRegistry::nodeTypeMetadata = {
        // ========== SOURCE NODES ==========
        {"rtsp_src",
         {"source",
          {"rtsp_url"},
          {"channel", "resize_ratio", "gst_decoder_name", "skip_interval",
           "codec_type"},
          "RTSP Source",
          "Receive video stream from RTSP URL"}},
        {"file_src",
         {"source",
          {"file_path"},
          {"channel", "resize_ratio"},
          "File Source",
          "Read video from file"}},
        {"app_src",
         {"source",
          {},
          {"channel"},
          "App Source",
          "Receive video frames from application"}},
        {"image_src",
         {"source",
          {"port_or_location"},
          {"interval", "resize_ratio", "cycle"},
          "Image Source",
          "Read images from file or UDP port"}},
        {"rtmp_src",
         {"source",
          {"rtmp_url"},
          {"channel", "resize_ratio", "skip_interval", "gst_decoder_name"},
          "RTMP Source",
          "Receive video stream from RTMP URL"}},
        {"udp_src",
         {"source",
          {"port"},
          {"resize_ratio", "skip_interval"},
          "UDP Source",
          "Receive video stream via UDP"}},
        {"ff_src",
         {"source",
          {"uri"},
          {"channel", "codec", "resize_ratio"},
          "FFmpeg Source",
          "Read video stream using FFmpeg"}},
        {"app_des",
         {"destination",
          {},
          {"channel"},
          "App Destination",
          "Output video frames to application"}},
        {"ff_des",
         {"destination",
          {"uri"},
          {"channel"},
          "FFmpeg Destination",
          "Output video stream using FFmpeg"}},
        {"image_des",
         {"destination",
          {"location"},
          {"channel", "interval", "size"},
          "Image Destination",
          "Save images to file or send via UDP"}},

        // ========== DETECTOR NODES ==========
        {"yunet_face_detector",
         {"detector",
          {"model_path"},
          {"score_threshold", "nms_threshold", "top_k"},
          "YuNet Face Detector",
          "Detect faces using YuNet model"}},
        {"yolo_detector",
         {"detector",
          {"weights_path", "config_path"},
          {"labels_path"},
          "YOLO Detector",
          "Object detection using YOLO"}},
        {"yolov11_detector",
         {"detector",
          {"model_path"},
          {},
          "YOLOv11 Detector",
          "Object detection using YOLOv11"}},
        {"mask_rcnn_detector",
         {"detector",
          {"model_path"},
          {},
          "Mask R-CNN Detector",
          "Object detection and segmentation using Mask R-CNN"}},
        {"openpose_detector",
         {"detector",
          {"model_path"},
          {},
          "OpenPose Detector",
          "Human pose estimation using OpenPose"}},
        {"enet_seg",
         {"detector",
          {"model_path"},
          {},
          "ENet Segmentation",
          "Semantic segmentation using ENet"}},

        // TensorRT Detectors
        {"trt_yolov8_detector",
         {"detector",
          {"model_path"},
          {},
          "TensorRT YOLOv8 Detector",
          "Object detection using TensorRT YOLOv8"}},
        {"trt_yolov8_seg_detector",
         {"detector",
          {"model_path"},
          {},
          "TensorRT YOLOv8 Segmentation",
          "Instance segmentation using TensorRT YOLOv8"}},
        {"trt_yolov8_pose_detector",
         {"detector",
          {"model_path"},
          {},
          "TensorRT YOLOv8 Pose",
          "Pose estimation using TensorRT YOLOv8"}},
        {"trt_yolov8_classifier",
         {"detector",
          {"model_path"},
          {},
          "TensorRT YOLOv8 Classifier",
          "Image classification using TensorRT YOLOv8"}},
        {"trt_vehicle_detector",
         {"detector",
          {"model_path"},
          {},
          "TensorRT Vehicle Detector",
          "Vehicle detection using TensorRT"}},
        {"trt_vehicle_plate_detector",
         {"detector",
          {"model_path"},
          {},
          "TensorRT Vehicle Plate Detector",
          "License plate detection using TensorRT"}},
        {"trt_vehicle_plate_detector_v2",
         {"detector",
          {"model_path"},
          {},
          "TensorRT Vehicle Plate Detector v2",
          "License plate detection using TensorRT (v2)"}},
        {"trt_insight_face_recognition",
         {"detector",
          {"model_path"},
          {},
          "TensorRT InsightFace Recognition",
          "Face recognition using TensorRT InsightFace"}},

        // RKNN Detectors
        {"rknn_yolov8_detector",
         {"detector",
          {"model_path"},
          {},
          "RKNN YOLOv8 Detector",
          "Object detection using RKNN YOLOv8"}},
        {"rknn_yolov11_detector",
         {"detector",
          {"model_path"},
          {},
          "RKNN YOLOv11 Detector",
          "Object detection using RKNN YOLOv11"}},
        {"rknn_face_detector",
         {"detector",
          {"model_path"},
          {},
          "RKNN Face Detector",
          "Face detection using RKNN"}},

        // PaddleOCR
        {"ppocr_text_detector",
         {"detector",
          {"model_path"},
          {},
          "PaddleOCR Text Detector",
          "Text detection using PaddleOCR"}},

        // Face Processing Nodes
        {"face_swap",
         {"detector",
          {"model_path"},
          {},
          "Face Swap",
          "Face swapping using deep learning"}},
        {"insight_face_recognition",
         {"detector",
          {"model_path"},
          {},
          "InsightFace Recognition",
          "Face recognition using InsightFace"}},
        {"mllm_analyser",
         {"detector",
          {"model_path"},
          {},
          "MLLM Analyser",
          "Multi-modal Large Language Model analyser"}},

        // ========== PROCESSOR NODES ==========
        {"sface_feature_encoder",
         {"processor",
          {"model_path"},
          {},
          "SFace Feature Encoder",
          "Extract face features using SFace"}},
        {"sort_track",
         {"processor",
          {},
          {},
          "SORT Tracker",
          "Track objects using SORT algorithm"}},
        {"bytetrack",
         {"processor",
          {},
          {"track_thresh", "high_thresh", "match_thresh", "track_buffer", "frame_rate", "track_for"},
          "ByteTrack Tracker",
          "Track objects using ByteTrack algorithm"}},
        {"ocsort",
         {"processor",
          {},
          {"det_thresh", "max_age", "min_hits", "iou_threshold", "delta_t", "asso_func", "inertia", "use_byte", "track_for"},
          "OCSort Tracker",
          "Track objects using OCSort algorithm"}},
        {"face_osd_v2",
         {"processor",
          {},
          {},
          "Face OSD v2",
          "Overlay face detection results"}},
        {"osd_v3",
         {"processor",
          {},
          {"font_path"},
          "OSD v3",
          "Overlay masks and labels (for Mask R-CNN, segmentation, etc.)"}},
        {"ba_crossline",
         {"processor",
          {},
          {"line_channel", "line_start_x", "line_start_y", "line_end_x",
           "line_end_y"},
          "BA Crossline",
          "Behavior analysis - crossline detection"}},
        {"ba_crossline_osd",
         {"processor",
          {},
          {},
          "BA Crossline OSD",
          "Overlay crossline detection results"}},
        {"classifier",
         {"processor",
          {"model_path"},
          {},
          "Classifier",
          "Image classification"}},
        {"lane_detector",
         {"processor",
          {"model_path"},
          {},
          "Lane Detector",
          "Detect lanes in road images"}},
        {"restoration",
         {"processor",
          {"model_path"},
          {},
          "Restoration",
          "Image restoration/enhancement"}},
        {"split",
         {"processor",
          {},
          {"split_by_channel", "deep_copy"},
          "Split",
          "Split frames by channel or deep copy"}},
        {"sync",
         {"processor",
          {},
          {"mode", "threshold"},
          "Sync",
          "Synchronize frames from multiple channels"}},
        {"custom_data_transform",
         {"processor",
          {},
          {},
          "Custom Data Transform",
          "Transform data using custom function"}},
        {"cluster",
         {"processor",
          {},
          {"enable", "labels", "threshold"},
          "Cluster",
          "Cluster objects based on features"}},
        {"frame_fusion",
         {"processor",
          {"src_cali_points", "des_cali_points"},
          {},
          "Frame Fusion",
          "Fuse frames from multiple channels"}},
        {"osd",
         {"processor", {}, {"font_path"}, "OSD", "Overlay detection results"}},
        {"face_osd",
         {"processor", {}, {}, "Face OSD", "Overlay face detection results"}},
        {"text_osd",
         {"processor",
          {"font_path"},
          {},
          "Text OSD",
          "Overlay text detection results"}},
        {"plate_osd",
         {"processor",
          {},
          {"font_path"},
          "Plate OSD",
          "Overlay license plate detection results"}},
        {"pose_osd",
         {"processor", {}, {}, "Pose OSD", "Overlay pose estimation results"}},
        {"seg_osd",
         {"processor",
          {},
          {},
          "Segmentation OSD",
          "Overlay segmentation results"}},
        {"lane_osd",
         {"processor", {}, {}, "Lane OSD", "Overlay lane detection results"}},
        {"mllm_osd",
         {"processor", {}, {}, "MLLM OSD", "Overlay MLLM analysis results"}},
        {"ba_jam",
         {"processor",
          {"regions"},
          {},
          "BA Jam",
          "Behavior analysis - traffic jam detection"}},
        {"ba_jam_osd",
         {"processor",
          {},
          {},
          "BA Jam OSD",
          "Overlay traffic jam detection results"}},
        {"ba_stop",
         {"processor",
          {"regions"},
          {},
          "BA Stop",
          "Behavior analysis - stop detection"}},
        {"ba_stop_osd",
         {"processor",
          {},
          {},
          "BA Stop OSD",
          "Overlay stop detection results"}},
        {"record",
         {"processor",
          {"image_dir", "video_dir"},
          {},
          "Record",
          "Record images and videos"}},

        // TensorRT Processors
        {"trt_vehicle_feature_encoder",
         {"processor",
          {"model_path"},
          {},
          "TensorRT Vehicle Feature Encoder",
          "Extract vehicle features using TensorRT"}},
        {"trt_vehicle_color_classifier",
         {"processor",
          {"model_path"},
          {},
          "TensorRT Vehicle Color Classifier",
          "Classify vehicle color using TensorRT"}},
        {"trt_vehicle_type_classifier",
         {"processor",
          {"model_path"},
          {},
          "TensorRT Vehicle Type Classifier",
          "Classify vehicle type using TensorRT"}},
        {"trt_vehicle_scanner",
         {"processor",
          {"model_path"},
          {},
          "TensorRT Vehicle Scanner",
          "Vehicle scanning and analysis using TensorRT"}},

        // ========== DESTINATION NODES ==========
        {"file_des",
         {"destination",
          {"save_dir"},
          {"name_prefix", "osd"},
          "File Destination",
          "Save video to file"}},
        {"rtmp_des",
         {"destination",
          {"rtmp_url"},
          {"channel"},
          "RTMP Destination",
          "Stream video via RTMP"}},
        {"screen_des",
         {"destination",
          {},
          {},
          "Screen Destination",
          "Display video on screen"}},
        {"fake_des",
         {"destination",
          {},
          {"channel"},
          "Fake Destination",
          "Fake destination for testing"}},
        {"rtsp_des",
         {"destination",
          {"rtsp_port"},
          {"channel", "rtsp_name", "stream_name", "resolution", "bitrate", "osd", "encoder"},
          "RTSP Destination",
          "Output video stream via RTSP server (requires CVEDIX_WITH_GSTREAMER)"}},

        // ========== BROKER NODES ==========
        {"json_console_broker",
         {"broker",
          {},
          {"broke_for"},
          "JSON Console Broker",
          "Output detection results to console as JSON"}},
        {"json_enhanced_console_broker",
         {"broker",
          {},
          {"broke_for", "encode_full_frame"},
          "JSON Enhanced Console Broker",
          "Enhanced JSON console output"}},
        {"json_mqtt_broker",
         {"broker",
          {"mqtt_broker", "mqtt_topic"},
          {"broke_for"},
          "JSON MQTT Broker",
          "Output detection results to MQTT"}},
        {"json_enhanced_mqtt_broker",
         {"broker",
          {"mqtt_broker", "mqtt_topic"},
          {"broke_for", "encode_full_frame"},
          "JSON Enhanced MQTT Broker",
          "Enhanced JSON output to MQTT with crop images"}},
        {"json_kafka_broker",
         {"broker",
          {"kafka_broker", "kafka_topic"},
          {"broke_for"},
          "JSON Kafka Broker",
          "Output detection results to Kafka"}},
        {"xml_file_broker",
         {"broker",
          {"file_path"},
          {},
          "XML File Broker",
          "Output detection results to XML file"}},
        {"xml_socket_broker",
         {"broker",
          {"socket_host", "socket_port"},
          {},
          "XML Socket Broker",
          "Output detection results via XML socket"}},
        {"msg_broker",
         {"broker", {}, {}, "Message Broker", "Generic message broker"}},
        {"ba_socket_broker",
         {"broker",
          {"socket_host", "socket_port"},
          {},
          "BA Socket Broker",
          "Behavior analysis socket broker"}},
        {"embeddings_socket_broker",
         {"broker",
          {"socket_host", "socket_port"},
          {},
          "Embeddings Socket Broker",
          "Face embeddings socket broker"}},
        {"embeddings_properties_socket_broker",
         {"broker",
          {"socket_host", "socket_port"},
          {},
          "Embeddings Properties Socket Broker",
          "Face embeddings with properties socket broker"}},
        {"plate_socket_broker",
         {"broker",
          {"socket_host", "socket_port"},
          {},
          "Plate Socket Broker",
          "License plate socket broker"}},
        {"expr_socket_broker",
         {"broker",
          {"socket_host", "socket_port"},
          {},
          "Expression Socket Broker",
          "Expression socket broker"}},
};

// Default parameters for specific node types
const std::map<std::string, std::map<std::string, std::string>>
    NodeTemplateRegistry::defaultParameters = {
        {"rtsp_src", {{"channel", "0"}, {"resize_ratio", "1.0"}}},
        {"file_src", {{"channel", "0"}, {"resize_ratio", "1.0"}}},
        {"app_src", {{"channel", "0"}}},
        {"image_src",
         {{"interval", "1"}, {"resize_ratio", "1.0"}, {"cycle", "true"}}},
        {"rtmp_src",
         {{"channel", "0"}, {"resize_ratio", "1.0"}, {"skip_interval", "0"}}},
        {"udp_src", {{"resize_ratio", "1.0"}, {"skip_interval", "0"}}},
        {"ff_src", {{"channel", "0"}, {"resize_ratio", "1.0"}}},
        {"app_des", {{"channel", "0"}}},
        {"ff_des", {{"channel", "0"}}},
        {"image_des", {{"channel", "0"}, {"interval", "1"}}},
        {"fake_des", {{"channel", "0"}}},
        {"rtsp_des", {{"channel", "0"}, {"port", "8000"}}},
        {"yunet_face_detector",
         {{"score_threshold", "0.7"},
          {"nms_threshold", "0.5"},
          {"top_k", "50"}}},
        {"file_des", {{"osd", "true"}}},
        {"rtmp_des", {{"channel", "0"}}},
        {"split", {{"split_by_channel", "true"}}},
        {"osd", {{"font_path", ""}}},
        {"ba_crossline",
         {{"line_channel", "0"},
          {"line_start_x", "0"},
          {"line_start_y", "250"},
          {"line_end_x", "700"},
          {"line_end_y", "220"}}},
        {"ba_jam",
         {{"jam_channel", "0"},
          {"jam_region_x_1", "20"},
          {"jam_region_y_1", "360"},
          {"jam_region_x_2", "400"},
          {"jam_region_y_2", "250"},
          {"jam_region_x_3", "535"},
          {"jam_region_y_3", "250"},
          {"jam_region_x_4", "555"},
          {"jam_region_y_4", "560"},
          {"jam_region_x_5", "30"},
          {"jam_region_y_5", "550"}}},
        {"json_console_broker", {{"broke_for", "NORMAL"}}},
        {"json_enhanced_mqtt_broker",
         {{"broke_for", "NORMAL"}, {"encode_full_frame", "false"}}},
};

std::vector<NodePoolManager::NodeTemplate>
NodeTemplateRegistry::importTemplatesFromSDK() {
  std::vector<NodePoolManager::NodeTemplate> templates;

  for (const auto &[nodeType, metadata] : nodeTypeMetadata) {
    NodePoolManager::NodeTemplate template_;
    template_.templateId = nodeType + "_template";
    template_.nodeType = nodeType;
    template_.displayName = metadata.displayName;
    template_.description = metadata.description;
    template_.category = metadata.category;
    template_.requiredParameters = metadata.requiredParameters;
    template_.optionalParameters = metadata.optionalParameters;

    // Add default parameters if available
    auto defaultIt = defaultParameters.find(nodeType);
    if (defaultIt != defaultParameters.end()) {
      template_.defaultParameters = defaultIt->second;
    }

    // Determine if pre-configured (no required parameters or all have defaults)
    template_.isPreConfigured = (metadata.requiredParameters.empty() ||
                                 defaultIt != defaultParameters.end());

    templates.push_back(template_);
  }

  return templates;
}
