Sleep operations:
/home/cvedix/project/edge_ai_api/src/main.cpp:44:#include <sys/wait.h>
/home/cvedix/project/edge_ai_api/src/main.cpp:156:                                // Use async with very short timeout (100ms) - just try to stop, don't wait
/home/cvedix/project/edge_ai_api/src/main.cpp:178:        std::this_thread::sleep_for(std::chrono::milliseconds(500));
/home/cvedix/project/edge_ai_api/src/main.cpp:264:            // This ensures we don't wait forever for RTSP retry loops
/home/cvedix/project/edge_ai_api/src/main.cpp:266:                std::this_thread::sleep_for(std::chrono::milliseconds(50));
/home/cvedix/project/edge_ai_api/src/main.cpp:323:                                    // RTSP retry loops can prevent stop() from returning, so we don't wait long
/home/cvedix/project/edge_ai_api/src/main.cpp:324:                                    auto status = future.wait_for(std::chrono::milliseconds(200));
/home/cvedix/project/edge_ai_api/src/main.cpp:328:                                        // Don't wait for it - continue with other instances
/home/cvedix/project/edge_ai_api/src/main.cpp:424:                std::this_thread::sleep_for(std::chrono::milliseconds(100));
/home/cvedix/project/edge_ai_api/src/main.cpp:562:                                auto status = future.wait_for(std::chrono::milliseconds(1000));
/home/cvedix/project/edge_ai_api/src/main.cpp:598:                std::this_thread::sleep_for(std::chrono::milliseconds(100));
/home/cvedix/project/edge_ai_api/src/main.cpp:689:                            auto status = future.wait_for(std::chrono::milliseconds(500));
/home/cvedix/project/edge_ai_api/src/main.cpp:726:                std::this_thread::sleep_for(std::chrono::milliseconds(100));
/home/cvedix/project/edge_ai_api/src/main.cpp:783:                        auto status = future.wait_for(std::chrono::milliseconds(500));
/home/cvedix/project/edge_ai_api/src/main.cpp:819:        // In this case, wait for cleanup to finish and then return (don't abort)
/home/cvedix/project/edge_ai_api/src/main.cpp:825:        // Wait a bit for cleanup to complete (but don't wait forever)
/home/cvedix/project/edge_ai_api/src/main.cpp:828:            std::this_thread::sleep_for(std::chrono::milliseconds(100));
/home/cvedix/project/edge_ai_api/src/main.cpp:1101:            std::this_thread::sleep_for(std::chrono::seconds(5));
/home/cvedix/project/edge_ai_api/src/main.cpp:1119:                    // Analysis board is disabled - just sleep and check again
/home/cvedix/project/edge_ai_api/src/main.cpp:1120:                    std::this_thread::sleep_for(std::chrono::seconds(5));
/home/cvedix/project/edge_ai_api/src/main.cpp:1150:                    std::this_thread::sleep_for(std::chrono::milliseconds(500));
/home/cvedix/project/edge_ai_api/src/main.cpp:1154:                    std::this_thread::sleep_for(std::chrono::milliseconds(2000));
/home/cvedix/project/edge_ai_api/src/main.cpp:1177:                std::this_thread::sleep_for(std::chrono::seconds(2));
/home/cvedix/project/edge_ai_api/src/main.cpp:1181:                    PLOG_INFO << "[Debug] No running instances - waiting for instances to start...";
/home/cvedix/project/edge_ai_api/src/main.cpp:1196:                std::this_thread::sleep_for(std::chrono::seconds(2));
/home/cvedix/project/edge_ai_api/src/main.cpp:1201:            std::this_thread::sleep_for(std::chrono::seconds(5));
/home/cvedix/project/edge_ai_api/src/main.cpp:1205:            std::this_thread::sleep_for(std::chrono::seconds(5));
/home/cvedix/project/edge_ai_api/src/main.cpp:1288:                auto status = future.wait_for(std::chrono::seconds(30));
/home/cvedix/project/edge_ai_api/src/main.cpp:1321:            std::this_thread::sleep_for(std::chrono::milliseconds(500));
/home/cvedix/project/edge_ai_api/src/main.cpp:2140:                    std::this_thread::sleep_for(std::chrono::seconds(30));
/home/cvedix/project/edge_ai_api/src/main.cpp:2189:                    std::this_thread::sleep_for(std::chrono::seconds(1));
/home/cvedix/project/edge_ai_api/src/main.cpp:2334:                                std::this_thread::sleep_for(std::chrono::milliseconds(3000));  // Increased delay
/home/cvedix/project/edge_ai_api/src/main.cpp:2396:                    std::this_thread::sleep_for(std::chrono::milliseconds(100));
/home/cvedix/project/edge_ai_api/src/instances/queue_monitor.cpp:141:        std::this_thread::sleep_for(std::chrono::seconds(monitoring_window_));
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:159:                waitForModelsReady(pipeline, 2000); // Max 2 seconds
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:286:                    std::this_thread::sleep_for(std::chrono::milliseconds(2000));
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:310:                // Catch any exceptions from waitForModelsReady or model validation (outer catch)
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:509:    // Check instance still exists before waiting
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:520:        waitForModelsReady(pipelineCopy, 2000); // 2 seconds max
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:522:        std::cerr << "[InstanceRegistry] ✗ Exception waiting for models: " << e.what() << std::endl;
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:530:        std::cerr << "[InstanceRegistry] ✗ Unknown exception waiting for models" << std::endl;
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:542:    std::this_thread::sleep_for(std::chrono::milliseconds(2000));
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:786:        std::this_thread::sleep_for(std::chrono::milliseconds(2000));
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:1096:                                std::cerr << "[InstanceRegistry] [MQTT] JSON reader thread started, waiting for data from json_console_broker..." << std::endl;
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:1154:                                    // Check stop flag after select (may have waited up to 200ms)
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:1485:                                                                        auto wait_start = std::chrono::steady_clock::now();
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:1489:                                                                        while (std::chrono::steady_clock::now() - wait_start < total_timeout) {
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:1495:                                                                            status = publish_future.wait_for(check_interval);
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:1561:                                                                                // Stop flag was set during wait, exit immediately
/home/cvedix/project/edge_ai_api/src/instances/instance_registry.cpp:1620:                                                    auto wait_start = std::chrono::steady_clock::now();
