#!/bin/bash
# ============================================
# Build All-In-One Debian Package
# ============================================
#
# Script này build package edge-ai-api "all-in-one" - tự chứa TẤT CẢ dependencies:
# - CVEDIX SDK runtime (bundled)
# - OpenCV libraries (bundled)
# - GStreamer libraries và plugins (bundled)
# - FFmpeg libraries và binaries (bundled)
# - Tất cả libraries khác (bundled)
#
# Package này chỉ cần system libraries cơ bản (libc6, libstdc++6, libgcc-s1)
# và có thể cài đặt trên bất kỳ Ubuntu/Debian nào mà không cần cài dependencies.
#
# Usage:
#   ./build_deb_all_in_one.sh [options]
#
# Options:
#   --sdk-deb PATH    Path to SDK .deb file (required)
#   --clean           Clean build directory trước khi build
#   --no-build        Skip build (chỉ tạo package từ build có sẵn)
#   --version VER     Set version (default: auto-detect)
#   --help            Hiển thị help
#
# ============================================

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Backup file paths for cleanup
RULES_BACKUP=""
CONTROL_BACKUP=""
POSTINST_BACKUP=""
RESTORE_NEEDED=false

# Configuration
ARCH="amd64"
CLEAN_BUILD=false
SKIP_BUILD=false
SKIP_OPENCV_BUILD=false
AUTO_INCREMENT=true
SDK_DEB_FILE=""

# Function to read version from VERSION file or CMakeLists.txt
read_version() {
    local version_file="$PROJECT_ROOT/VERSION"
    local cmake_file="$PROJECT_ROOT/CMakeLists.txt"
    
    if [ -f "$version_file" ]; then
        cat "$version_file" | head -1 | tr -d '[:space:]'
    elif [ -f "$cmake_file" ]; then
        grep -E "project\(.*VERSION" "$cmake_file" | sed -E 's/.*VERSION[[:space:]]+([0-9.]+).*/\1/' | head -1
    else
        echo "2026.0.1.1"  # Default fallback
    fi
}

# Function to increment version (increment last number)
increment_version() {
    local version="$1"
    # Split version by dots
    IFS='.' read -ra PARTS <<< "$version"
    local major="${PARTS[0]}"
    local minor="${PARTS[1]}"
    local patch="${PARTS[2]}"
    local build="${PARTS[3]:-0}"
    
    # Increment build number (last number)
    build=$((build + 1))
    
    echo "$major.$minor.$patch.$build"
}

# Function to update version in all files
update_version_files() {
    local new_version="$1"
    local version_file="$PROJECT_ROOT/VERSION"
    local cmake_file="$PROJECT_ROOT/CMakeLists.txt"
    local changelog_file="$PROJECT_ROOT/debian/changelog"
    
    echo "Updating version to $new_version in all files..."
    
    # Update VERSION file
    echo "$new_version" > "$version_file"
    echo -e "${GREEN}✓${NC} Updated $version_file"
    
    # Update CMakeLists.txt
    if [ -f "$cmake_file" ]; then
        sed -i "s/project(edge_ai_api VERSION [0-9.]*)/project(edge_ai_api VERSION $new_version)/" "$cmake_file"
        echo -e "${GREEN}✓${NC} Updated CMakeLists.txt"
    fi
    
    # Update debian/changelog
    if [ -f "$changelog_file" ]; then
        # Update first line of changelog
        sed -i "1s/edge-ai-api ([0-9.]*)/edge-ai-api ($new_version)/" "$changelog_file"
        echo -e "${GREEN}✓${NC} Updated debian/changelog"
    fi
}

# Function to create bundle_libs.sh script (ALL-IN-ONE version)
create_bundle_libs_script() {
    local BUNDLE_SCRIPT="$PROJECT_ROOT/debian/bundle_libs.sh"

    if [ ! -f "$BUNDLE_SCRIPT" ] || [ "$CLEAN_BUILD" = true ]; then
        echo "Creating bundle_libs.sh script (ALL-IN-ONE mode)..."
        cat > "$BUNDLE_SCRIPT" <<'BUNDLE_SCRIPT_EOF'
#!/bin/bash
# Bundle ALL libraries for All-In-One Debian package
# This script is auto-generated by build_deb_all_in_one.sh
# Bundles: OpenCV, GStreamer, FFmpeg (libraries + binaries), and all other dependencies

set -e

EXEC_PATH="$1"
LIB_TEMP_DIR="$2"

if [ -z "$EXEC_PATH" ] || [ -z "$LIB_TEMP_DIR" ]; then
    echo "Usage: $0 <executable> <lib_dir>"
    exit 1
fi

if [ ! -f "$EXEC_PATH" ]; then
    echo "Error: Executable not found: $EXEC_PATH"
    exit 1
fi

mkdir -p "$LIB_TEMP_DIR"

echo "Bundling libraries from $EXEC_PATH..."

# Copy libraries from build directory
BUILD_LIB_DIR=$(dirname "$EXEC_PATH")/../lib
if [ -d "$BUILD_LIB_DIR" ]; then
    cp -L "$BUILD_LIB_DIR"/*.so* "$LIB_TEMP_DIR/" 2>/dev/null || true
fi

# Bundle libopencv_freetype.so.410 (required for CVEDIX SDK compatibility)
# This file is created from OpenCV 4.6's libopencv_freetype.so.4.6.0
# Must be bundled early to ensure it's not overwritten by other OpenCV libraries
echo "Bundling libopencv_freetype.so.410 (CVEDIX SDK compatibility)..."
FREETYPE_410_BUNDLED=false

# Check if file already exists (may have been copied from BUILD_LIB_DIR above)
if [ -f "$LIB_TEMP_DIR/libopencv_freetype.so.410" ]; then
    FREETYPE_410_BUNDLED=true
    echo "  ✓ libopencv_freetype.so.410 already bundled (from build/lib)"
else
    # First, check if it's in build/lib (created by CMakeLists.txt)
    if [ -d "$BUILD_LIB_DIR" ] && [ -f "$BUILD_LIB_DIR/libopencv_freetype.so.410" ]; then
        echo "  Copying libopencv_freetype.so.410 from build/lib..."
        cp -L "$BUILD_LIB_DIR/libopencv_freetype.so.410" "$LIB_TEMP_DIR/" 2>/dev/null && FREETYPE_410_BUNDLED=true || true
    fi
    
    # If not found in build/lib, try to copy from system OpenCV 4.6 and rename
    if [ "$FREETYPE_410_BUNDLED" = false ] && [ ! -f "$LIB_TEMP_DIR/libopencv_freetype.so.410" ]; then
        FREETYPE_SOURCES=(
            "/usr/lib/x86_64-linux-gnu/libopencv_freetype.so.4.6.0"
            "/usr/lib/x86_64-linux-gnu/libopencv_freetype.so.406"
            "/usr/local/lib/libopencv_freetype.so.4.6.0"
            "/usr/local/lib/libopencv_freetype.so.406"
            "/usr/lib/libopencv_freetype.so.4.6.0"
            "/usr/lib/libopencv_freetype.so.406"
        )
        
        for source in "${FREETYPE_SOURCES[@]}"; do
            if [ -f "$source" ]; then
                echo "  Copying $source as libopencv_freetype.so.410..."
                cp -L "$source" "$LIB_TEMP_DIR/libopencv_freetype.so.410" 2>/dev/null && FREETYPE_410_BUNDLED=true && break || true
            fi
        done
    fi
fi

# Final verification and cleanup
if [ -f "$LIB_TEMP_DIR/libopencv_freetype.so.410" ]; then
    echo "  ✓ libopencv_freetype.so.410 bundled successfully"
    
    # Remove any other freetype versions to avoid conflicts
    for freetype_file in "$LIB_TEMP_DIR"/libopencv_freetype.so.*; do
        if [ -f "$freetype_file" ] && [[ "$(basename "$freetype_file")" != "libopencv_freetype.so.410"* ]]; then
            echo "  Removing conflicting file: $(basename "$freetype_file")"
            rm -f "$freetype_file" 2>/dev/null || true
        fi
    done
else
    echo "  ⚠ Warning: libopencv_freetype.so.410 not found"
    echo "    This file is required for CVEDIX SDK compatibility"
    echo "    The service may fail to start without this file"
    echo "    Ensure OpenCV 4.6 is installed on build machine or CMakeLists.txt creates this file"
fi

# Copy CVEDIX SDK libraries if available (from extracted SDK)
if [ -d "/opt/cvedix/lib" ]; then
    cp -L /opt/cvedix/lib/libcvedix*.so* "$LIB_TEMP_DIR/" 2>/dev/null || true
    cp -L /opt/cvedix/lib/libtinyexpr.so* "$LIB_TEMP_DIR/" 2>/dev/null || true
fi

# Copy CUDA libraries if available (for GPU acceleration support)
CUDA_LIB_PATHS=(
    "/usr/local/cuda/lib64"
    "/usr/local/cuda/lib"
    "/usr/lib/x86_64-linux-gnu"
    "/opt/cuda/lib64"
    "/opt/cuda/lib"
)

CUDA_LIBS=(
    "libcublas.so*"
    "libcublasLt.so*"
    "libcurand.so*"
    "libcusolver.so*"
    "libcufft.so*"
    "libcusparse.so*"
    "libcudart.so*"
    "libnvrtc.so*"
    "libnvjitlink.so*"
)

CUDA_FOUND=false
for cuda_path in "${CUDA_LIB_PATHS[@]}"; do
    if [ -d "$cuda_path" ]; then
        for cuda_lib_pattern in "${CUDA_LIBS[@]}"; do
            find "$cuda_path" -maxdepth 1 -name "$cuda_lib_pattern" -type f 2>/dev/null | while read cuda_lib; do
                if [ -f "$cuda_lib" ]; then
                    libname=$(basename "$cuda_lib")
                    if [ ! -f "$LIB_TEMP_DIR/$libname" ]; then
                        echo "  Copying CUDA library $libname from $cuda_path..."
                        cp -L "$cuda_lib" "$LIB_TEMP_DIR/" 2>/dev/null || true
                    fi
                fi
            done
        done
        if find "$cuda_path" -maxdepth 1 -name "libcublas*.so*" -type f 2>/dev/null | grep -q .; then
            CUDA_FOUND=true
        fi
    fi
done

if [ "$CUDA_FOUND" = true ]; then
    echo "  CUDA libraries bundled successfully"
fi

# Copy hwinfo libraries from build directory
EXEC_DIR=$(dirname "$EXEC_PATH")
if [[ "$EXEC_DIR" == *"/bin" ]]; then
    BUILD_DIR=$(dirname "$EXEC_DIR")
else
    BUILD_DIR="$EXEC_DIR"
fi
HWINFO_LIB_PATHS=(
    "$BUILD_DIR/_deps/hwinfo-build"
    "$BUILD_DIR/third_party/hwinfo"
    "$BUILD_DIR"
)
HWINFO_FOUND=false
for hwinfo_path in "${HWINFO_LIB_PATHS[@]}"; do
    if [ -d "$hwinfo_path" ]; then
        while IFS= read -r hwinfo_lib; do
            if [ -f "$hwinfo_lib" ]; then
                libname=$(basename "$hwinfo_lib")
                if [ ! -f "$LIB_TEMP_DIR/$libname" ]; then
                    echo "  Copying hwinfo library $libname from $hwinfo_path..."
                    cp -L "$hwinfo_lib" "$LIB_TEMP_DIR/" 2>/dev/null || true
                    HWINFO_FOUND=true
                fi
            fi
        done < <(find "$hwinfo_path" -name "libhwinfo*.so*" -type f 2>/dev/null)
    fi
done

if [ "$HWINFO_FOUND" = true ]; then
    echo "  hwinfo libraries bundled successfully"
fi

# ============================================
# ALL-IN-ONE: Bundle ALL libraries including OpenCV, GStreamer, FFmpeg (libraries + binaries)
# ============================================

# Bundle OpenCV libraries (if available in system)
echo "Bundling OpenCV libraries..."
OPENCV_PATHS=(
    "/usr/lib/x86_64-linux-gnu"
    "/usr/local/lib"
    "/usr/local/lib/x86_64-linux-gnu"
    "/usr/lib"
)
for opencv_path in "${OPENCV_PATHS[@]}"; do
    if [ -d "$opencv_path" ]; then
        find "$opencv_path" -maxdepth 1 -name "libopencv*.so*" -type f 2>/dev/null | while read opencv_lib; do
            if [ -f "$opencv_lib" ]; then
                libname=$(basename "$opencv_lib")
                
                # CRITICAL: Always skip libopencv_freetype.so versions other than .410
                # The .410 version will be copied by debian/rules after bundle_libs.sh runs
                # This prevents conflicts and ensures the correct version is used
                if [[ "$libname" == "libopencv_freetype.so"* ]] && [[ "$libname" != "libopencv_freetype.so.410"* ]]; then
                    echo "  Skipping $libname (libopencv_freetype.so.410 will be bundled separately)"
                    continue
                fi
                
                if [ ! -f "$LIB_TEMP_DIR/$libname" ]; then
                    echo "  Copying OpenCV library $libname..."
                    cp -L "$opencv_lib" "$LIB_TEMP_DIR/" 2>/dev/null || true
                fi
            fi
        done
    fi
done


# Bundle GStreamer libraries
echo "Bundling GStreamer libraries..."
GST_PATHS=(
    "/usr/lib/x86_64-linux-gnu"
    "/usr/local/lib"
    "/usr/lib"
)
for gst_path in "${GST_PATHS[@]}"; do
    if [ -d "$gst_path" ]; then
        # GStreamer core libraries
        find "$gst_path" -maxdepth 1 \( -name "libgstreamer*.so*" -o -name "libgst*.so*" \) -type f 2>/dev/null | while read gst_lib; do
            if [ -f "$gst_lib" ]; then
                libname=$(basename "$gst_lib")
                if [ ! -f "$LIB_TEMP_DIR/$libname" ]; then
                    echo "  Copying GStreamer library $libname..."
                    cp -L "$gst_lib" "$LIB_TEMP_DIR/" 2>/dev/null || true
                fi
            fi
        done
    fi
done

# Bundle GStreamer plugins
echo "Bundling GStreamer plugins..."
GST_PLUGIN_PATHS=(
    "/usr/lib/x86_64-linux-gnu/gstreamer-1.0"
    "/usr/local/lib/gstreamer-1.0"
    "/usr/lib/gstreamer-1.0"
)
mkdir -p "$LIB_TEMP_DIR/gstreamer-1.0"
PLUGIN_COUNT=0
for gst_plugin_path in "${GST_PLUGIN_PATHS[@]}"; do
    if [ -d "$gst_plugin_path" ]; then
        find "$gst_plugin_path" -maxdepth 1 -name "libgst*.so" -type f 2>/dev/null | while read gst_plugin; do
            if [ -f "$gst_plugin" ]; then
                libname=$(basename "$gst_plugin")
                if [ ! -f "$LIB_TEMP_DIR/gstreamer-1.0/$libname" ]; then
                    echo "  Copying GStreamer plugin $libname..."
                    cp -L "$gst_plugin" "$LIB_TEMP_DIR/gstreamer-1.0/" 2>/dev/null && PLUGIN_COUNT=$((PLUGIN_COUNT + 1)) || true
                fi
            fi
        done
    fi
done

# Verify critical plugins were bundled
if [ -d "$LIB_TEMP_DIR/gstreamer-1.0" ]; then
    FINAL_COUNT=$(ls -1 "$LIB_TEMP_DIR/gstreamer-1.0"/*.so 2>/dev/null | wc -l)
    echo "  ✓ Bundled $FINAL_COUNT GStreamer plugin(s)"
    
    # Check for critical plugins
    CRITICAL_PLUGINS=("libgstcoreelements.so" "libgstplayback.so" "libgstvideo.so")
    MISSING_PLUGINS=()
    for plugin in "${CRITICAL_PLUGINS[@]}"; do
        if [ ! -f "$LIB_TEMP_DIR/gstreamer-1.0/$plugin" ]; then
            MISSING_PLUGINS+=("$plugin")
        fi
    done
    
    if [ ${#MISSING_PLUGINS[@]} -gt 0 ]; then
        echo "  ⚠ Warning: Missing critical plugins: ${MISSING_PLUGINS[*]}"
        echo "    Some GStreamer features may not work on target machine"
        echo "    Ensure GStreamer plugins are installed on build machine:"
        echo "      sudo apt-get install gstreamer1.0-plugins-base gstreamer1.0-plugins-good"
    else
        echo "  ✓ All critical plugins bundled"
    fi
else
    echo "  ⚠ Warning: GStreamer plugins directory not created"
    echo "    GStreamer features will not work on target machine"
fi

# Bundle FFmpeg libraries
echo "Bundling FFmpeg libraries..."
for gst_path in "${GST_PATHS[@]}"; do
    if [ -d "$gst_path" ]; then
        find "$gst_path" -maxdepth 1 \( -name "libavcodec*.so*" -o -name "libavformat*.so*" -o -name "libavutil*.so*" -o -name "libswscale*.so*" -o -name "libswresample*.so*" \) -type f 2>/dev/null | while read ffmpeg_lib; do
            if [ -f "$ffmpeg_lib" ]; then
                libname=$(basename "$ffmpeg_lib")
                if [ ! -f "$LIB_TEMP_DIR/$libname" ]; then
                    echo "  Copying FFmpeg library $libname..."
                    cp -L "$ffmpeg_lib" "$LIB_TEMP_DIR/" 2>/dev/null || true
                fi
            fi
        done
    fi
done

# Note: FFmpeg binaries (ffmpeg, ffprobe) will be bundled in debian/rules
# during package installation, not here in bundle_libs.sh
# This is because bundle_libs.sh only handles libraries, not binaries

# Collect other required libraries from ldd output
ALL_LIBS=$(mktemp)
trap "rm -f $ALL_LIBS" EXIT

collect_libs() {
    local binary="$1"
    if [ -f "$binary" ]; then
        ldd "$binary" 2>/dev/null | grep -v "not found" | awk '{print $3}' | grep -v "^$" >> "$ALL_LIBS" || true
    fi
}

echo "Collecting libraries from main executable..."
collect_libs "$EXEC_PATH"

WORKER_PATH=$(dirname "$EXEC_PATH")/edge_ai_worker
if [ -f "$WORKER_PATH" ]; then
    echo "Collecting libraries from edge_ai_worker..."
    collect_libs "$WORKER_PATH"
fi

CORE_LIB_PATH=$(dirname "$EXEC_PATH")/../lib/libedge_ai_core.so*
if ls $CORE_LIB_PATH 1> /dev/null 2>&1; then
    for core_lib in $CORE_LIB_PATH; do
        if [ -f "$core_lib" ]; then
            echo "Collecting libraries from $(basename "$core_lib")..."
            collect_libs "$core_lib"
        fi
    done
fi

if [ -d "$BUILD_LIB_DIR" ]; then
    for lib_file in "$BUILD_LIB_DIR"/*.so*; do
        if [ -f "$lib_file" ] && [ ! -L "$lib_file" ]; then
            collect_libs "$lib_file"
        fi
    done
fi

# Copy all unique libraries (including dependencies of bundled libraries)
sort -u "$ALL_LIBS" | while read lib; do
    if [ -f "$lib" ]; then
        libname=$(basename "$lib")
        case "$libname" in
            libc.so*|libm.so*|libpthread.so*|libdl.so*|libgcc_s.so*|libstdc++.so*|ld-linux*)
                continue
                ;;
            *)
                if [ ! -f "$LIB_TEMP_DIR/$libname" ]; then
                    echo "  Copying $libname from $lib..."
                    cp -L "$lib" "$LIB_TEMP_DIR/" 2>/dev/null || true
                fi
                ;;
        esac
    fi
done

# Resolve symlinks
for pass in 1 2 3; do
    changed=false
    for lib in "$LIB_TEMP_DIR"/*.so*; do
        if [ -L "$lib" ] 2>/dev/null; then
            target=$(readlink -f "$lib")
            target_name=$(basename "$target")
            if [ -f "$target" ] && [ ! -f "$LIB_TEMP_DIR/$target_name" ]; then
                echo "  Resolving symlink: $(basename "$lib") -> $target_name"
                cp -L "$target" "$LIB_TEMP_DIR/" 2>/dev/null || true
                changed=true
            fi
        fi
    done
    [ "$changed" = false ] && break
done

# Final pass: ensure all symlinks point to files that exist
for lib in "$LIB_TEMP_DIR"/*.so*; do
    if [ -L "$lib" ] 2>/dev/null; then
        target=$(readlink -f "$lib")
        if [ ! -f "$target" ]; then
            target_name=$(basename "$target")
            if [ -f "$LIB_TEMP_DIR/$target_name" ]; then
                rm -f "$lib"
                ln -sf "$target_name" "$lib" 2>/dev/null || true
            fi
        fi
    fi
done

echo "Libraries bundled successfully."
BUNDLE_SCRIPT_EOF
        chmod +x "$BUNDLE_SCRIPT"
        echo -e "${GREEN}✓${NC} Created bundle_libs.sh"
    else
        echo -e "${GREEN}✓${NC} bundle_libs.sh already exists"
    fi
}

# Cleanup function to restore files on error
cleanup() {
    local exit_code=$?
    if [ "$RESTORE_NEEDED" = true ] && [ $exit_code -ne 0 ]; then
        echo ""
        echo -e "${YELLOW}Build failed. Restoring original files...${NC}"
        if [ -f "$RULES_BACKUP" ] && [ -f "$PROJECT_ROOT/debian/rules" ]; then
            mv "$RULES_BACKUP" "$PROJECT_ROOT/debian/rules" 2>/dev/null || true
            echo "  Restored debian/rules"
        fi
        if [ -f "$CONTROL_BACKUP" ] && [ -f "$PROJECT_ROOT/debian/control" ]; then
            mv "$CONTROL_BACKUP" "$PROJECT_ROOT/debian/control" 2>/dev/null || true
            echo "  Restored debian/control"
        fi
        if [ -f "$POSTINST_BACKUP" ] && [ -f "$PROJECT_ROOT/debian/postinst" ]; then
            mv "$POSTINST_BACKUP" "$PROJECT_ROOT/debian/postinst" 2>/dev/null || true
            echo "  Restored debian/postinst"
        fi
    fi
}

# Set trap to cleanup on exit
trap cleanup EXIT INT TERM

# Read current version
VERSION=$(read_version)

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --sdk-deb)
            SDK_DEB_FILE="$2"
            shift 2
            ;;
        --clean)
            CLEAN_BUILD=true
            shift
            ;;
        --no-build)
            SKIP_BUILD=true
            shift
            ;;
        --skip-opencv)
            SKIP_OPENCV_BUILD=true
            shift
            ;;
        --version)
            VERSION="$2"
            AUTO_INCREMENT=false
            shift 2
            ;;
        --no-increment)
            AUTO_INCREMENT=false
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --sdk-deb PATH   Path to SDK .deb file (required)"
            echo "  --clean          Clean build directory before building"
            echo "  --no-build       Skip build (use existing build)"
            echo "  --skip-opencv    Skip OpenCV 4.10 build (use system OpenCV)"
            echo "  --version VER    Set package version (disables auto-increment)"
            echo "  --no-increment   Don't auto-increment version"
            echo "  --help, -h       Show this help"
            echo ""
            echo "Example:"
            echo "  ./build_deb_with_sdk.sh --sdk-deb ../cvedix-ai-runtime-2025.0.1.3-x86_64.deb"
            echo "  ./build_deb_with_sdk.sh --sdk-deb ../cvedix-ai-runtime-2025.0.1.3-x86_64.deb --clean"
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Run '$0 --help' for usage information"
            exit 1
            ;;
    esac
done

# Validate SDK .deb file
if [ -z "$SDK_DEB_FILE" ]; then
    echo -e "${RED}Error: --sdk-deb is required${NC}"
    echo "Run '$0 --help' for usage information"
    exit 1
fi

# Resolve absolute path
if [ ! -f "$SDK_DEB_FILE" ]; then
    # Try relative to project root
    if [ -f "$PROJECT_ROOT/$SDK_DEB_FILE" ]; then
        SDK_DEB_FILE="$PROJECT_ROOT/$SDK_DEB_FILE"
    else
        echo -e "${RED}Error: SDK .deb file not found: $SDK_DEB_FILE${NC}"
        exit 1
    fi
else
    SDK_DEB_FILE=$(readlink -f "$SDK_DEB_FILE")
fi

# Verify it's a valid .deb file
if ! dpkg-deb -I "$SDK_DEB_FILE" >/dev/null 2>&1; then
    echo -e "${RED}Error: Invalid .deb file: $SDK_DEB_FILE${NC}"
    exit 1
fi

echo -e "${GREEN}✓${NC} SDK .deb file validated: $SDK_DEB_FILE"

# Auto-increment version if enabled
if [ "$AUTO_INCREMENT" = true ]; then
    OLD_VERSION="$VERSION"
    VERSION=$(increment_version "$VERSION")
    echo "=========================================="
    echo "Auto-Incrementing Version"
    echo "=========================================="
    echo "Old version: $OLD_VERSION"
    echo "New version: $VERSION"
    echo ""
    update_version_files "$VERSION"
    echo ""
fi

echo "=========================================="
echo "Build Debian Package with SDK Bundled"
echo "=========================================="
echo "Version: $VERSION"
echo "Architecture: $ARCH"
echo "SDK Package: $SDK_DEB_FILE"
echo ""

cd "$PROJECT_ROOT"

# ============================================
# Step 1: Extract SDK .deb file
# ============================================
echo -e "${BLUE}[1/6]${NC} Extracting SDK package..."
SDK_EXTRACT_DIR="$PROJECT_ROOT/debian/sdk_extract"
rm -rf "$SDK_EXTRACT_DIR"
mkdir -p "$SDK_EXTRACT_DIR"

# Extract SDK .deb (extract both data and control)
dpkg-deb -x "$SDK_DEB_FILE" "$SDK_EXTRACT_DIR"
dpkg-deb -e "$SDK_DEB_FILE" "$SDK_EXTRACT_DIR/DEBIAN" 2>/dev/null || true

# Get SDK package info
SDK_PKG_NAME=$(dpkg-deb -f "$SDK_DEB_FILE" Package)
SDK_PKG_VERSION=$(dpkg-deb -f "$SDK_DEB_FILE" Version)
SDK_PKG_ARCH=$(dpkg-deb -f "$SDK_DEB_FILE" Architecture)

echo -e "${GREEN}✓${NC} SDK extracted: $SDK_PKG_NAME ($SDK_PKG_VERSION, $SDK_PKG_ARCH)"
echo "  SDK contents: $SDK_EXTRACT_DIR"

# List what was extracted for verification
if [ -d "$SDK_EXTRACT_DIR/opt/cvedix" ]; then
    echo "  SDK directories found:"
    find "$SDK_EXTRACT_DIR/opt/cvedix" -type d -maxdepth 2 | sed 's|^.*/opt/cvedix/|    - |' | head -10
    echo "  SDK libraries found:"
    find "$SDK_EXTRACT_DIR/opt/cvedix/lib" -name "*.so*" -type f 2>/dev/null | sed 's|^.*/|    - |' | head -10 || echo "    (none found)"
else
    echo -e "${YELLOW}  ⚠  Warning: /opt/cvedix not found in SDK package${NC}"
    echo "  Checking alternative locations..."
    find "$SDK_EXTRACT_DIR" -type d -maxdepth 3 | head -10
fi
echo ""

# ============================================
# Step 2: Check Build Dependencies
# ============================================
echo -e "${BLUE}[2/6]${NC} Checking build dependencies..."
MISSING_DEPS=()

# Check for commands
for dep in cmake make dpkg-deb; do
    if ! command -v $dep &>/dev/null; then
        MISSING_DEPS+=($dep)
    fi
done

# Check for dpkg-buildpackage
if ! command -v dpkg-buildpackage &>/dev/null; then
    MISSING_DEPS+=(dpkg-dev)
fi

# Check for debhelper
if ! command -v dh &>/dev/null && ! dpkg -l | grep -q "^ii.*debhelper"; then
    MISSING_DEPS+=(debhelper)
fi

# Check for fakeroot
if ! command -v fakeroot &>/dev/null; then
    MISSING_DEPS+=(fakeroot)
fi

# Check build dependencies from debian/control
if [ -f "debian/control" ]; then
    BUILD_DEPS_TEXT=$(awk '/^Build-Depends:/ {flag=1; sub(/^Build-Depends: */, ""); print; next} flag && /^[A-Z]/ {flag=0} flag {print}' debian/control | tr '\n' ' ')

    while IFS=',' read -ra DEPS; do
        for dep_raw in "${DEPS[@]}"; do
            dep=$(echo "$dep_raw" | sed 's/([^)]*)//g' | sed 's/|.*$//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            [ -z "$dep" ] && continue

            if command -v "$dep" &>/dev/null; then
                continue
            fi

            if ! dpkg-query -W -f='${Status}' "$dep" 2>/dev/null | grep -q "install ok installed"; then
                found=false
                for existing_dep in "${MISSING_DEPS[@]}"; do
                    if [ "$existing_dep" = "$dep" ]; then
                        found=true
                        break
                    fi
                done
                if [ "$found" = false ]; then
                    MISSING_DEPS+=($dep)
                fi
            fi
        done
    done <<< "$BUILD_DEPS_TEXT"
fi

if [ ${#MISSING_DEPS[@]} -gt 0 ]; then
    echo -e "${RED}Error: Missing dependencies: ${MISSING_DEPS[*]}${NC}"
    echo ""
    echo "Install with:"
    echo "  sudo apt-get update"
    echo "  sudo apt-get install -y ${MISSING_DEPS[*]}"
    exit 1
fi
echo -e "${GREEN}✓${NC} All build dependencies available"
echo ""

# ============================================
# Step 2.5: Install System Dependencies
# ============================================
echo -e "${BLUE}[2.5/9]${NC} Installing/checking system dependencies..."
echo "Checking for required system packages..."

REQUIRED_PACKAGES=(
    "build-essential"
    "make"
    "cmake"
    "debhelper"
    "dpkg-dev"
    "mosquitto"
    "mosquitto-clients"
    "unzip"
    "libmosquitto-dev"
    "libturbojpeg"
    "libturbojpeg0-dev"
    "libgstreamer1.0-dev"
    "libgstreamer-plugins-base1.0-dev"
    "gstreamer1.0-plugins-good"
    "gstreamer1.0-plugins-bad"
    "gstreamer1.0-plugins-ugly"
    "gstreamer1.0-tools"
    "pkg-config"
    "libssl-dev"
    "libcurl4-openssl-dev"
    "libjson-c-dev"
    "libgstreamer1.0-0"
    "gstreamer1.0-plugins-base"
    "gstreamer1.0-libav"
    "gstreamer1.0-x"
    "gstreamer1.0-alsa"
    "gstreamer1.0-gl"
    "gstreamer1.0-gtk3"
    "gstreamer1.0-qt5"
    "gstreamer1.0-pulseaudio"
    "python3-gst-1.0"
    "libgstrtspserver-1.0-dev"
    "gstreamer1.0-rtsp"
    "git"
    "libgtk-3-dev"
    "libavcodec-dev"
    "libavformat-dev"
    "libswscale-dev"
    "libv4l-dev"
    "libxvidcore-dev"
    "libx264-dev"
    "libjpeg-dev"
    "libpng-dev"
    "libtiff-dev"
    "gfortran"
    "openexr"
    "libatlas-base-dev"
    "python3-dev"
    "python3-numpy"
)

MISSING_PACKAGES=()
for pkg in "${REQUIRED_PACKAGES[@]}"; do
    if ! dpkg-query -W -f='${Status}' "$pkg" 2>/dev/null | grep -q "install ok installed"; then
        MISSING_PACKAGES+=("$pkg")
    fi
done

if [ ${#MISSING_PACKAGES[@]} -gt 0 ]; then
    echo -e "${YELLOW}Missing packages: ${MISSING_PACKAGES[*]}${NC}"
    echo "Installing missing packages..."
    sudo apt-get update
    
    # Try to install all packages at once, but continue if some fail
    if sudo apt-get install -y "${MISSING_PACKAGES[@]}" 2>&1; then
        echo -e "${GREEN}✓${NC} Dependencies installed"
    else
        # Check which packages were actually installed
        INSTALLED_COUNT=0
        for pkg in "${MISSING_PACKAGES[@]}"; do
            if dpkg-query -W -f='${Status}' "$pkg" 2>/dev/null | grep -q "install ok installed"; then
                INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
            else
                echo -e "${YELLOW}  ⚠  Package $pkg could not be installed (may not be available)${NC}"
            fi
        done
        
        if [ $INSTALLED_COUNT -gt 0 ]; then
            echo -e "${GREEN}✓${NC} Installed $INSTALLED_COUNT out of ${#MISSING_PACKAGES[@]} packages"
            echo -e "${YELLOW}⚠${NC}  Some packages may be optional or have different names"
        else
            echo -e "${RED}Error: Could not install any of the missing packages${NC}"
            echo "Please check package names and repository availability"
            exit 1
        fi
    fi
else
    echo -e "${GREEN}✓${NC} All required packages are installed"
fi
echo ""

# ============================================
# Step 3: Build OpenCV 4.10 (if needed) - ONLY at build machine
# ============================================
# NOTE: OpenCV will be built at BUILD machine, then bundled into package
# At user machine, only dependencies will be auto-installed via apt
if [ "$SKIP_OPENCV_BUILD" = false ]; then
    echo -e "${BLUE}[3/10]${NC} Checking OpenCV installation (for bundling)..."
    
    # Check if OpenCV 4.10 is already installed
    OPENCV_VERSION=""
    OPENCV_LIB_PATH=""
    
    if command -v opencv_version &>/dev/null; then
        OPENCV_VERSION=$(opencv_version 2>/dev/null | head -1 || echo "")
    fi
    
    # Check common OpenCV library paths (more comprehensive search)
    OPENCV_PATHS=(
        "/usr/local/lib"
        "/usr/local/lib/x86_64-linux-gnu"
        "/usr/lib/x86_64-linux-gnu"
        "/usr/lib"
    )
    
    # Find OpenCV 4.10 libraries
    for path in "${OPENCV_PATHS[@]}"; do
        if [ -d "$path" ]; then
            # Check for OpenCV 4.10 libraries (various naming conventions)
            if find "$path" -maxdepth 1 -name "libopencv_core.so.4.10*" -o -name "libopencv_core.so.410*" 2>/dev/null | grep -q .; then
                OPENCV_LIB_PATH="$path"
                echo "  ✓ Found OpenCV 4.10 libraries at: $OPENCV_LIB_PATH"
                break
            fi
        fi
    done
    
    # Also try pkg-config to find OpenCV path
    if [ -z "$OPENCV_LIB_PATH" ] && command -v pkg-config >/dev/null 2>&1; then
        OPENCV_PKG_LIBDIR=$(pkg-config --variable=libdir opencv4 2>/dev/null || pkg-config --variable=libdir opencv 2>/dev/null || echo "")
        if [ -n "$OPENCV_PKG_LIBDIR" ] && [ -d "$OPENCV_PKG_LIBDIR" ]; then
            if find "$OPENCV_PKG_LIBDIR" -maxdepth 1 -name "libopencv_core.so.4.10*" -o -name "libopencv_core.so.410*" 2>/dev/null | grep -q .; then
                OPENCV_LIB_PATH="$OPENCV_PKG_LIBDIR"
                echo "  ✓ Found OpenCV 4.10 libraries via pkg-config at: $OPENCV_LIB_PATH"
            fi
        fi
    fi
    
    # Check if we need to build OpenCV 4.10
    NEED_OPENCV_BUILD=false
    if [ -z "$OPENCV_LIB_PATH" ]; then
        # No OpenCV 4.10 libraries found, check version string
        if [ -z "$OPENCV_VERSION" ] || ! echo "$OPENCV_VERSION" | grep -qE "^4\.(10|1[1-9]|[2-9][0-9])"; then
            NEED_OPENCV_BUILD=true
            echo "  OpenCV 4.10+ not found, will build OpenCV 4.10 for bundling"
        else
            echo "  ⚠  OpenCV $OPENCV_VERSION found but libraries not in standard paths"
            echo "  Will try to bundle from /usr/local/lib during package build"
            OPENCV_LIB_PATH="/usr/local/lib"
        fi
    else
        if [ -n "$OPENCV_VERSION" ] && echo "$OPENCV_VERSION" | grep -qE "^4\.(10|1[1-9]|[2-9][0-9])"; then
            echo "  ✓ OpenCV $OPENCV_VERSION confirmed at $OPENCV_LIB_PATH"
        else
            echo "  ✓ OpenCV 4.10 libraries found at $OPENCV_LIB_PATH (version check skipped)"
        fi
    fi
    
    if [ "$NEED_OPENCV_BUILD" = true ]; then
        OPENCV_SCRIPT="$PROJECT_ROOT/scripts/build_opencv_safe.sh"
        if [ -f "$OPENCV_SCRIPT" ]; then
            echo "Building OpenCV 4.10 (this will be bundled into package)..."
            echo ""
            echo "Note: build_opencv_safe.sh will automatically:"
            echo "  - Detect NVIDIA GPU if present"
            echo "  - Detect CUDA Toolkit if installed"
            echo "  - Offer to install CUDA Toolkit if GPU detected but CUDA missing"
            echo "  - Build OpenCV with CUDA support if CUDA is available"
            echo "  - Build OpenCV CPU-only if CUDA is not available"
            echo ""
            
            # Check for NVIDIA GPU before building
            if command -v nvidia-smi >/dev/null 2>&1; then
                if nvidia-smi --query-gpu=name --format=csv,noheader 2>/dev/null | head -1 | grep -q .; then
                    GPU_NAME=$(nvidia-smi --query-gpu=name --format=csv,noheader 2>/dev/null | head -1)
                    echo -e "${GREEN}✓${NC} NVIDIA GPU detected: $GPU_NAME"
                    
                    # Check if CUDA Toolkit is installed
                    if command -v nvcc >/dev/null 2>&1 && ([ -d "/usr/local/cuda" ] || [ -d "/opt/cuda" ]); then
                        CUDA_VERSION=$(nvcc --version 2>/dev/null | grep "release" | sed 's/.*release \([0-9.]*\).*/\1/' || echo "unknown")
                        echo -e "${GREEN}✓${NC} CUDA Toolkit detected: version $CUDA_VERSION"
                        echo "  OpenCV will be built with CUDA support"
                        echo "  CUDA libraries will be bundled into package"
                    else
                        echo -e "${YELLOW}⚠${NC}  CUDA Toolkit not found"
                        echo "  build_opencv_safe.sh will offer to install CUDA Toolkit automatically"
                        echo "  If installed, OpenCV will be built with CUDA support"
                    fi
                fi
            else
                echo "  No NVIDIA GPU detected - OpenCV will be built CPU-only"
            fi
            echo ""
            
            chmod +x "$OPENCV_SCRIPT"
            cd "$PROJECT_ROOT"
            "$OPENCV_SCRIPT" || {
                echo ""
                echo -e "${YELLOW}⚠${NC}  OpenCV build failed, will use system OpenCV libraries..."
                echo -e "${YELLOW}⚠${NC}  Note: User machine will need OpenCV 4.10+ installed"
            }
            cd "$PROJECT_ROOT"
            
            # Check if CUDA libraries were built with OpenCV
            if [ -d "/usr/local/lib" ]; then
                if find /usr/local/lib -maxdepth 1 -name "libopencv_cuda*.so*" 2>/dev/null | grep -q .; then
                    echo ""
                    echo -e "${GREEN}✓${NC} OpenCV CUDA libraries detected - will be bundled into package"
                fi
            fi
            
            # Update OpenCV library path after build
            OPENCV_LIB_PATH="/usr/local/lib"
        else
            echo -e "${YELLOW}⚠${NC}  build_opencv_safe.sh not found, using system OpenCV"
            echo -e "${YELLOW}⚠${NC}  Note: User machine will need OpenCV 4.10+ installed"
        fi
    fi
    
    # Store OpenCV library path for bundling (save to file for debian/rules to use)
    if [ -n "$OPENCV_LIB_PATH" ]; then
        echo "$OPENCV_LIB_PATH" > "$PROJECT_ROOT/debian/opencv_lib_path.txt"
        echo "  Saved OpenCV library path: $OPENCV_LIB_PATH"
        echo "  OpenCV libraries will be bundled from: $OPENCV_LIB_PATH"
    else
        # Remove old path file if exists
        rm -f "$PROJECT_ROOT/debian/opencv_lib_path.txt"
    fi
    
    echo ""
else
    echo -e "${YELLOW}[3/10]${NC} Skipping OpenCV build (using system OpenCV)"
    # Still try to find and bundle OpenCV if available
    OPENCV_LIB_PATH=""
    for path in "/usr/local/lib" "/usr/lib/x86_64-linux-gnu" "/usr/lib"; do
        if [ -d "$path" ] && find "$path" -maxdepth 1 -name "libopencv_core.so.4.10*" -o -name "libopencv_core.so.410*" 2>/dev/null | grep -q .; then
            OPENCV_LIB_PATH="$path"
            echo "$OPENCV_LIB_PATH" > "$PROJECT_ROOT/debian/opencv_lib_path.txt"
            echo "  Found OpenCV 4.10 at $OPENCV_LIB_PATH, will bundle"
            break
        fi
    done
    if [ -z "$OPENCV_LIB_PATH" ]; then
        echo -e "${YELLOW}  Note: User machine will need OpenCV 4.10+ installed${NC}"
    fi
    echo ""
fi

# ============================================
# Step 4: Clean (if requested)
# ============================================
if [ "$CLEAN_BUILD" = true ]; then
    echo -e "${BLUE}[3/6]${NC} Cleaning build directory..."
    rm -rf build
    rm -rf debian/edge-ai-api
    rm -f ../edge-ai-api_*.deb ../edge-ai-api_*.changes ../edge-ai-api_*.buildinfo
    echo -e "${GREEN}✓${NC} Cleaned"
    echo ""
fi

# ============================================
# Step 5: Build Project
# ============================================
if [ "$SKIP_BUILD" = false ]; then
    echo -e "${BLUE}[5/9]${NC} Building project..."

    if [ ! -d "build" ]; then
        mkdir -p build
    fi

    cd build

    if [ ! -f "CMakeCache.txt" ]; then
        echo "Running CMake..."
        cmake .. -DCMAKE_BUILD_TYPE=Release \
                 -DAUTO_DOWNLOAD_DEPENDENCIES=ON \
                 -DDROGON_USE_FETCHCONTENT=ON
    fi

    echo "Building (using all CPU cores)..."
    CPU_CORES=$(nproc)
    echo "Using $CPU_CORES CPU cores..."
    make -j$CPU_CORES

    # Ensure libopencv_freetype.so.410 is created in build/lib
    # This is required for CVEDIX SDK compatibility
    echo "Ensuring libopencv_freetype.so.410 is available..."
    mkdir -p lib
    FREETYPE_410_PATH="lib/libopencv_freetype.so.410"
    if [ ! -f "$FREETYPE_410_PATH" ]; then
        # Try to copy from various sources
        FREETYPE_SOURCES=(
            "/usr/lib/x86_64-linux-gnu/libopencv_freetype.so.4.6.0"
            "/usr/lib/x86_64-linux-gnu/libopencv_freetype.so.406"
            "/usr/local/lib/libopencv_freetype.so.4.6.0"
            "/usr/local/lib/libopencv_freetype.so.406"
            "/usr/lib/libopencv_freetype.so.4.6.0"
            "/usr/lib/libopencv_freetype.so.406"
        )
        
        FREETYPE_COPIED=false
        for source in "${FREETYPE_SOURCES[@]}"; do
            if [ -f "$source" ]; then
                echo "  Copying $source to $FREETYPE_410_PATH..."
                cp -L "$source" "$FREETYPE_410_PATH" 2>/dev/null && FREETYPE_COPIED=true && break || true
            fi
        done
        
        if [ "$FREETYPE_COPIED" = true ]; then
            echo -e "  ${GREEN}✓${NC} libopencv_freetype.so.410 created in build/lib"
        else
            echo -e "  ${YELLOW}⚠${NC}  Warning: libopencv_freetype.so.410 not found in system"
            echo "  The package build will try to copy it from system during packaging"
        fi
    else
        echo -e "  ${GREEN}✓${NC} libopencv_freetype.so.410 already exists in build/lib"
    fi

    cd ..
    echo -e "${GREEN}✓${NC} Build completed"
    echo ""
else
    echo -e "${YELLOW}[5/9]${NC} Skipping build (using existing build)"
    echo ""
fi

# Check if executable exists
EXECUTABLE=""
EXECUTABLE_PATHS=(
    "build/bin/edge_ai_api"
    "build/edge_ai_api"
    "build/edge_ai_api/edge_ai_api"
)

for path in "${EXECUTABLE_PATHS[@]}"; do
    if [ -f "$path" ] && [ -x "$path" ]; then
        EXECUTABLE="$path"
        break
    fi
done

if [ -z "$EXECUTABLE" ]; then
    echo -e "${RED}Error: Executable not found${NC}"
    echo "Checked the following locations:"
    for path in "${EXECUTABLE_PATHS[@]}"; do
        echo "  - $path"
    done
    echo ""
    echo "Please build the project first or remove --no-build flag"
    exit 1
fi

echo "Found executable: $EXECUTABLE"

# ============================================
# Step 5.5: Create bundle_libs.sh script
# ============================================
echo -e "${BLUE}[5.5/10]${NC} Creating bundle_libs.sh script..."
create_bundle_libs_script
echo ""

# ============================================
# Step 6: Modify debian/rules with SDK bundling
# ============================================
echo -e "${BLUE}[6/10]${NC} Modifying debian/rules with SDK bundling..."

# Backup original rules
RULES_FILE="$PROJECT_ROOT/debian/rules"
RULES_BACKUP="$PROJECT_ROOT/debian/rules.backup"
if [ ! -f "$RULES_BACKUP" ]; then
    cp "$RULES_FILE" "$RULES_BACKUP"
    echo "  Backed up original rules to $RULES_BACKUP"
fi
RESTORE_NEEDED=true

# Verify SDK bundling section exists and is correct
echo "  Verifying SDK bundling in debian/rules..."
if ! grep -q "SDK_EXTRACT_DIR = \$(CURDIR)/debian/sdk_extract" "$RULES_FILE"; then
    echo "  Adding SDK_EXTRACT_DIR definition..."
    sed -i '/^SERVICE_GROUP = edgeai$/a\
\
# SDK configuration\
SDK_EXTRACT_DIR = $(CURDIR)/debian/sdk_extract\
CVEDIX_INSTALL_DIR = /opt/cvedix' "$RULES_FILE"
fi

# Verify SDK bundling section exists
if ! grep -q "# Install CVEDIX SDK from extracted .deb" "$RULES_FILE"; then
    echo -e "${YELLOW}  ⚠  Warning: SDK bundling section not found in rules${NC}"
    echo "  Rules file should already have SDK bundling section. Please check manually."
fi

# Verify bundle_libs.sh check exists
if ! grep -q "if \[ -f \$(CURDIR)/debian/bundle_libs.sh \]; then" "$RULES_FILE"; then
    echo "  Note: bundle_libs.sh check should be in rules (already fixed in current rules)"
fi

chmod +x "$RULES_FILE"
echo -e "${GREEN}✓${NC} Verified debian/rules has SDK bundling support"
echo ""

# ============================================
# Step 7: Update debian/postinst to setup SDK
# ============================================
echo -e "${BLUE}[7/9]${NC} Updating debian/postinst for SDK setup..."

# Backup original postinst
POSTINST_FILE="$PROJECT_ROOT/debian/postinst"
POSTINST_BACKUP="$PROJECT_ROOT/debian/postinst.backup"
if [ ! -f "$POSTINST_BACKUP" ]; then
    cp "$POSTINST_FILE" "$POSTINST_BACKUP"
    echo "  Backed up original postinst to $POSTINST_BACKUP"
fi
RESTORE_NEEDED=true

# Add SDK and OpenCV setup to postinst (after bundle_libraries call)
if ! grep -q "# Setup CVEDIX SDK library path" "$POSTINST_FILE"; then
    # Find where bundle_libraries is called (standalone line, not function definition) and add SDK setup after it
    # Use a temporary file to insert multiline code
    SDK_SETUP_TMP=$(mktemp)
    cat > "$SDK_SETUP_TMP" <<'SDK_SETUP_EOF'

# Setup CVEDIX SDK library path (SDK is bundled in this package)
echo "Setting up CVEDIX SDK library path..."
if [ -d "/opt/cvedix/lib" ]; then
    echo "/opt/cvedix/lib" > /etc/ld.so.conf.d/cvedix.conf
    echo "  ✓ Added /opt/cvedix/lib to library search path"
    ldconfig 2>&1 | grep -v "is not a symbolic link" || true
else
    echo "  ⚠  Warning: /opt/cvedix/lib not found (SDK may not be properly installed)"
fi

# Check OpenCV installation (bundled or system)
echo "Checking OpenCV installation..."
OPENCV_FOUND=false
if [ -d "$INSTALL_DIR/lib" ]; then
    # Check if OpenCV is bundled
    if find "$INSTALL_DIR/lib" -name "libopencv_core.so.4.10*" -o -name "libopencv_core.so.410*" 2>/dev/null | grep -q .; then
        echo "  ✓ OpenCV 4.10 libraries found in bundled lib directory"
        OPENCV_FOUND=true
    fi
fi

# Check system OpenCV
if [ "$OPENCV_FOUND" = false ]; then
    if command -v opencv_version >/dev/null 2>&1; then
        OPENCV_VER=$(opencv_version 2>/dev/null | head -1 || echo "")
        if echo "$OPENCV_VER" | grep -qE "^4\.(10|1[1-9]|[2-9][0-9])"; then
            echo "  ✓ OpenCV $OPENCV_VER found in system"
            OPENCV_FOUND=true
        else
            echo "  ⚠  OpenCV version $OPENCV_VER found, but 4.10+ is recommended"
        fi
    fi
fi

if [ "$OPENCV_FOUND" = false ]; then
    echo "  ⚠  Warning: OpenCV 4.10+ not found"
    echo "  You may need to install OpenCV 4.10+ or ensure bundled libraries are available"
fi
SDK_SETUP_EOF
    
    # Insert after bundle_libraries() function call (not function definition)
    # Look for "bundle_libraries" as a standalone line (function call)
    if grep -q "^bundle_libraries$" "$POSTINST_FILE"; then
        # Insert after the standalone bundle_libraries call
        awk -v setup_file="$SDK_SETUP_TMP" '
        /^bundle_libraries$/ {
            print
            while ((getline line < setup_file) > 0) {
                print line
            }
            close(setup_file)
            next
        }
        { print }
        ' "$POSTINST_FILE" > "$POSTINST_FILE.tmp" && mv "$POSTINST_FILE.tmp" "$POSTINST_FILE"
        echo -e "${GREEN}✓${NC} Updated debian/postinst with SDK and OpenCV setup"
    else
        # Try to find bundle_libraries call in a different format
        # Look for line that calls bundle_libraries (might be indented)
        if grep -q "bundle_libraries" "$POSTINST_FILE"; then
            # Find the line and insert after it
            awk -v setup_file="$SDK_SETUP_TMP" '
            /bundle_libraries/ && !/^[[:space:]]*#/ && !/function/ {
                print
                while ((getline line < setup_file) > 0) {
                    print line
                }
                close(setup_file)
                next
            }
            { print }
            ' "$POSTINST_FILE" > "$POSTINST_FILE.tmp" && mv "$POSTINST_FILE.tmp" "$POSTINST_FILE"
            echo -e "${GREEN}✓${NC} Updated debian/postinst with SDK and OpenCV setup"
        else
            echo -e "${YELLOW}  ⚠  Could not find bundle_libraries call in postinst${NC}"
            echo "  SDK setup will be added at the end of the script"
            cat "$SDK_SETUP_TMP" >> "$POSTINST_FILE"
            echo -e "${GREEN}✓${NC} Added SDK setup to end of debian/postinst"
        fi
    fi
    
    rm -f "$SDK_SETUP_TMP"
    
    # Verify SDK setup was added
    if grep -q "# Setup CVEDIX SDK library path" "$POSTINST_FILE"; then
        echo -e "${GREEN}✓${NC} Verified SDK setup in postinst"
    else
        echo -e "${YELLOW}  ⚠  Warning: SDK setup may not have been added correctly${NC}"
    fi
else
    echo -e "${GREEN}✓${NC} postinst already contains SDK setup"
fi
echo ""

# ============================================
# Step 8: Update debian/control to include SDK runtime dependencies
# ============================================
echo -e "${BLUE}[8/10]${NC} Updating debian/control with SDK dependencies..."

# Backup original control
CONTROL_FILE="$PROJECT_ROOT/debian/control"
CONTROL_BACKUP="$PROJECT_ROOT/debian/control.backup"
if [ ! -f "$CONTROL_BACKUP" ]; then
    cp "$CONTROL_FILE" "$CONTROL_BACKUP"
    echo "  Backed up original control to $CONTROL_BACKUP"
fi
RESTORE_NEEDED=true

# Read SDK dependencies from SDK .deb
SDK_DEPENDS=$(dpkg-deb -f "$SDK_DEB_FILE" Depends 2>/dev/null || echo "")

# Update control file for ALL-IN-ONE package - minimal dependencies only
# All libraries (OpenCV, GStreamer, FFmpeg, etc.) are bundled in the package
cat > "$CONTROL_FILE" <<CONTROL_EOF
Source: edge-ai-api
Section: net
Priority: optional
Maintainer: CVEDIX <support@cvedix.com>
Build-Depends: debhelper (>= 13),
               cmake (>= 3.14),
               build-essential,
               make,
               git,
               unzip,
               libssl-dev,
               libcurl4-openssl-dev,
               zlib1g-dev,
               libjsoncpp-dev,
               libjson-c-dev,
               uuid-dev,
               pkg-config,
               libopencv-dev,
               libgstreamer1.0-dev,
               libgstreamer-plugins-base1.0-dev,
               libgstrtspserver-1.0-dev,
               libmosquitto-dev,
               mosquitto,
               mosquitto-clients,
               libturbojpeg0-dev | libturbojpeg-dev,
               gstreamer1.0-tools,
               python3-gst-1.0,
               gstreamer1.0-rtsp,
               libgtk-3-dev,
               libavcodec-dev,
               libavformat-dev,
               libswscale-dev,
               libv4l-dev,
               libxvidcore-dev,
               libx264-dev,
               libjpeg-dev,
               libpng-dev,
               libtiff-dev,
               gfortran,
               openexr,
               libatlas-base-dev,
               python3-dev,
               python3-numpy
Standards-Version: 4.6.0
Homepage: https://github.com/cvedix/edge_ai_api

Package: edge-ai-api
Architecture: amd64
Depends: ${misc:Depends},
         libc6,
         libstdc++6,
         libgcc-s1,
         adduser,
         systemd
Description: Edge AI API Server - ALL-IN-ONE Package
 Edge AI API Server provides a RESTful control plane for managing
 CVEDIX Edge AI SDK instances remotely. It allows backend services
 or remote operators to configure, launch, and monitor real-time
 computer vision instances on edge devices without direct access.
 .
 This is an ALL-IN-ONE package that includes:
  - CVEDIX SDK runtime (bundled)
  - OpenCV libraries (bundled)
  - GStreamer libraries and plugins (bundled)
  - FFmpeg libraries (bundled)
  - All other dependencies (bundled)
 .
 No additional dependencies need to be installed. The package is
 self-contained and can be installed on any Ubuntu/Debian system
 with only basic system libraries (libc6, libstdc++6, libgcc-s1).
 .
 Features:
  - RESTful API for instance management
  - WebSocket support for real-time monitoring
  - Swagger UI for API exploration
  - Systemd service integration
  - Comprehensive logging and monitoring
  - All dependencies bundled (no external dependencies required)
CONTROL_EOF

echo -e "${GREEN}✓${NC} Updated debian/control with SDK dependencies"
echo ""

# ============================================
# Step 9: Update changelog
# ============================================
echo -e "${BLUE}[9/9]${NC} Updating changelog..."
if [ -f "debian/changelog" ]; then
    # Add note about SDK bundling
    sed -i "s/edge-ai-api (.*) unstable/edge-ai-api ($VERSION) unstable/" debian/changelog
    # Add entry about SDK bundling if not already present
    if ! grep -q "CVEDIX SDK bundled" debian/changelog; then
        sed -i "1a\\
  * Package now includes CVEDIX SDK runtime bundled\\
  * No separate SDK installation required\\
" debian/changelog
    fi
    echo -e "${GREEN}✓${NC} Changelog updated"
else
    echo -e "${YELLOW}⚠${NC}  debian/changelog not found, skipping..."
fi
echo ""

# ============================================
# Step 10: Build Debian Package
# ============================================
echo -e "${BLUE}[10/10]${NC} Building Debian package..."
export DEB_BUILD_OPTIONS="parallel=$(nproc)"

# Build package
echo "Running dpkg-buildpackage..."
dpkg-buildpackage -b -us -uc

# Find the generated .deb file
DEB_FILE=$(find .. -maxdepth 1 -name "edge-ai-api_${VERSION}_${ARCH}.deb" -o -name "edge-ai-api_*.deb" 2>/dev/null | head -1)

if [ -z "$DEB_FILE" ]; then
    DEB_FILE=$(find .. -maxdepth 1 -name "*.deb" -type f 2>/dev/null | grep edge-ai-api | head -1)
fi

if [ -z "$DEB_FILE" ]; then
    echo -e "${RED}Error: Could not find generated .deb file${NC}"
    echo "Check build output above for errors"
    exit 1
fi

# Get absolute path and move to project root with proper name
DEB_FILE=$(readlink -f "$DEB_FILE")
FINAL_NAME="edge-ai-api-all-in-one-${VERSION}-${ARCH}.deb"

if [ "$(basename "$DEB_FILE")" != "$FINAL_NAME" ]; then
    mv "$DEB_FILE" "$PROJECT_ROOT/$FINAL_NAME"
    DEB_FILE="$PROJECT_ROOT/$FINAL_NAME"
else
    if [ "$(dirname "$DEB_FILE")" != "$PROJECT_ROOT" ]; then
        mv "$DEB_FILE" "$PROJECT_ROOT/$FINAL_NAME"
        DEB_FILE="$PROJECT_ROOT/$FINAL_NAME"
    fi
fi

# Clean up temporary files
rm -rf debian/edge-ai-api
rm -rf debian/sdk_extract
rm -f debian/opencv_lib_path.txt
rm -f ../edge-ai-api_*.changes ../edge-ai-api_*.buildinfo 2>/dev/null || true

# Restore original files (cleanup will be handled by trap)
# Files will be restored automatically on exit via cleanup function
RESTORE_NEEDED=false  # Disable restore since we want to keep modified files after successful build

# Generate version manifest
if [ -f "$PROJECT_ROOT/packaging/scripts/generate_version_manifest.sh" ] && [ -f "$EXECUTABLE" ]; then
    echo ""
    echo "Generating version manifest..."
    MANIFEST_FILE="$PROJECT_ROOT/version_manifest_${VERSION}.txt"
    "$PROJECT_ROOT/packaging/scripts/generate_version_manifest.sh" "$EXECUTABLE" "$MANIFEST_FILE"
    if [ -f "$MANIFEST_FILE" ]; then
        echo -e "${GREEN}✓${NC} Version manifest: $MANIFEST_FILE"
    fi
fi

echo ""
echo "=========================================="
echo -e "${GREEN}✓ ALL-IN-ONE Package built successfully!${NC}"
echo "=========================================="
echo ""
echo "Package: $FINAL_NAME"
echo "Location: $DEB_FILE"
echo "Size: $(du -h "$DEB_FILE" | cut -f1)"
echo ""
echo "Bundled Components:"
echo "  ✓ CVEDIX SDK runtime"
echo "  ✓ OpenCV libraries"
if [ -d "/usr/local/lib" ] && find /usr/local/lib -maxdepth 1 -name "libopencv_cuda*.so*" 2>/dev/null | grep -q .; then
    echo "    → OpenCV built with CUDA support (GPU acceleration enabled)"
elif command -v nvcc >/dev/null 2>&1 && ([ -d "/usr/local/cuda" ] || [ -d "/opt/cuda" ]); then
    echo "    → CUDA Toolkit detected (OpenCV may have CUDA support)"
else
    echo "    → OpenCV built CPU-only (no GPU acceleration)"
fi
echo "  ✓ GStreamer libraries and plugins"
echo "  ✓ FFmpeg libraries and binaries"
echo "  ✓ All other dependencies"
echo ""
echo "SDK Information:"
echo "  SDK Package: $SDK_PKG_NAME ($SDK_PKG_VERSION)"
echo "  SDK bundled: Yes"
echo ""
echo "=========================================="
echo "Installation Instructions"
echo "=========================================="
echo ""
echo "1. Install package (ALL dependencies included):"
echo "   sudo dpkg -i $FINAL_NAME"
echo ""
echo "2. No additional dependencies needed!"
echo "   This package is self-contained and includes everything."
echo ""
echo "3. Verify installation:"
echo "   sudo /opt/edge_ai_api/scripts/validate_installation.sh --verbose"
echo ""
echo "4. Start the service:"
echo "   sudo systemctl start edge-ai-api"
echo ""
echo "5. Check status:"
echo "   sudo systemctl status edge-ai-api"
echo ""
echo "=========================================="
echo "Note"
echo "=========================================="
echo ""
echo "This is an ALL-IN-ONE package that includes:"
echo "  - CVEDIX SDK runtime (bundled)"
echo "  - OpenCV libraries (bundled)"
echo "  - GStreamer libraries and plugins (bundled)"
echo "  - FFmpeg libraries and binaries (bundled)"
echo "  - All other dependencies (bundled)"
echo ""
echo "No additional dependencies need to be installed."
echo "The package can be installed on any Ubuntu/Debian system"
echo "with only basic system libraries (libc6, libstdc++6, libgcc-s1)."
echo ""

