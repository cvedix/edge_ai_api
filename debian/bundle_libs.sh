#!/bin/bash
# Bundle libraries for Debian package
# This script is auto-generated by build_deb.sh

set -e

EXEC_PATH="$1"
LIB_TEMP_DIR="$2"

if [ -z "$EXEC_PATH" ] || [ -z "$LIB_TEMP_DIR" ]; then
    echo "Usage: $0 <executable> <lib_dir>"
    exit 1
fi

if [ ! -f "$EXEC_PATH" ]; then
    echo "Error: Executable not found: $EXEC_PATH"
    exit 1
fi

mkdir -p "$LIB_TEMP_DIR"

echo "Bundling libraries from $EXEC_PATH..."

# Copy libraries from build directory
BUILD_LIB_DIR=$(dirname "$EXEC_PATH")/../lib
if [ -d "$BUILD_LIB_DIR" ]; then
    cp -L "$BUILD_LIB_DIR"/*.so* "$LIB_TEMP_DIR/" 2>/dev/null || true
fi

# Copy CVEDIX SDK libraries if available
# Copy CVEDIX SDK libraries if available
# Check both old and new SDK locations for compatibility
if [ -d "/opt/cvedix-ai-runtime/lib/cvedix" ]; then
    cp -L /opt/cvedix-ai-runtime/lib/cvedix/libcvedix*.so* "$LIB_TEMP_DIR/" 2>/dev/null || true
    cp -L /opt/cvedix-ai-runtime/lib/cvedix/libtinyexpr.so* "$LIB_TEMP_DIR/" 2>/dev/null || true
elif [ -d "/opt/cvedix/lib" ]; then
    cp -L /opt/cvedix/lib/libcvedix*.so* "$LIB_TEMP_DIR/" 2>/dev/null || true
    cp -L /opt/cvedix/lib/libtinyexpr.so* "$LIB_TEMP_DIR/" 2>/dev/null || true
fi

# Copy CUDA libraries if available (for GPU acceleration support)
# Detect CUDA installation from common paths
CUDA_LIB_PATHS=(
    "/usr/local/cuda/lib64"
    "/usr/local/cuda/lib"
    "/usr/lib/x86_64-linux-gnu"
    "/opt/cuda/lib64"
    "/opt/cuda/lib"
)

CUDA_LIBS=(
    "libcublas.so*"
    "libcublasLt.so*"
    "libcurand.so*"
    "libcusolver.so*"
    "libcufft.so*"
    "libcusparse.so*"
    "libcudart.so*"
    "libnvrtc.so*"
    "libnvjitlink.so*"
)

CUDA_FOUND=false
for cuda_path in "${CUDA_LIB_PATHS[@]}"; do
    if [ -d "$cuda_path" ]; then
        # Check if any CUDA libraries exist in this path
        for cuda_lib_pattern in "${CUDA_LIBS[@]}"; do
            if find "$cuda_path" -maxdepth 1 -name "$cuda_lib_pattern" -type f 2>/dev/null | grep -q .; then
                CUDA_FOUND=true
                # Find and copy CUDA libraries
                find "$cuda_path" -maxdepth 1 -name "$cuda_lib_pattern" -type f 2>/dev/null | while read cuda_lib; do
                    if [ -f "$cuda_lib" ]; then
                        libname=$(basename "$cuda_lib")
                        if [ ! -f "$LIB_TEMP_DIR/$libname" ]; then
                            echo "  Copying CUDA library $libname from $cuda_path..."
                            cp -L "$cuda_lib" "$LIB_TEMP_DIR/" 2>/dev/null || true
                        fi
                    fi
                done
            fi
        done
    fi
done

if [ "$CUDA_FOUND" = true ]; then
    echo "  CUDA libraries bundled successfully"
fi

# Copy hwinfo libraries from build directory
# hwinfo libraries are built as part of the project but may not be in system paths
EXEC_DIR=$(dirname "$EXEC_PATH")
# Find build directory: go up from exec dir until we find a directory named "build" or use exec dir's parent
if [[ "$EXEC_DIR" == *"/bin" ]]; then
    BUILD_DIR=$(dirname "$EXEC_DIR")
else
    BUILD_DIR="$EXEC_DIR"
fi
HWINFO_LIB_PATHS=(
    "$BUILD_DIR/_deps/hwinfo-build"
    "$BUILD_DIR/third_party/hwinfo"
    "$BUILD_DIR"
)
HWINFO_FOUND=false
for hwinfo_path in "${HWINFO_LIB_PATHS[@]}"; do
    if [ -d "$hwinfo_path" ]; then
        # Find all libhwinfo*.so* files
        while IFS= read -r hwinfo_lib; do
            if [ -f "$hwinfo_lib" ]; then
                libname=$(basename "$hwinfo_lib")
                if [ ! -f "$LIB_TEMP_DIR/$libname" ]; then
                    echo "  Copying hwinfo library $libname from $hwinfo_path..."
                    cp -L "$hwinfo_lib" "$LIB_TEMP_DIR/" 2>/dev/null || true
                    HWINFO_FOUND=true
                fi
            fi
        done < <(find "$hwinfo_path" -name "libhwinfo*.so*" -type f 2>/dev/null)
    fi
done

if [ "$HWINFO_FOUND" = true ]; then
    echo "  hwinfo libraries bundled successfully"
fi

# Copy other required libraries from ldd output (including OpenCV and GStreamer for full package)
# Bundle all required libraries for a self-contained package
# Collect all libraries from multiple sources
ALL_LIBS=$(mktemp)
trap "rm -f $ALL_LIBS" EXIT

# Function to collect libraries from a binary/library
collect_libs() {
    local binary="$1"
    if [ -f "$binary" ]; then
        ldd "$binary" 2>/dev/null | grep -v "not found" | awk '{print $3}' | grep -v "^$" >> "$ALL_LIBS" || true
    fi
}

# Collect from main executable
echo "Collecting libraries from main executable..."
collect_libs "$EXEC_PATH"

# Also check edge_ai_worker if it exists
WORKER_PATH=$(dirname "$EXEC_PATH")/edge_ai_worker
if [ -f "$WORKER_PATH" ]; then
    echo "Collecting libraries from edge_ai_worker..."
    collect_libs "$WORKER_PATH"
fi

# Also check edge_ai_core library if it exists
CORE_LIB_PATH=$(dirname "$EXEC_PATH")/../lib/libedge_ai_core.so*
if ls $CORE_LIB_PATH 1> /dev/null 2>&1; then
    for core_lib in $CORE_LIB_PATH; do
        if [ -f "$core_lib" ]; then
            echo "Collecting libraries from $(basename "$core_lib")..."
            collect_libs "$core_lib"
        fi
    done
fi

# Also collect from all libraries already in build/lib
if [ -d "$BUILD_LIB_DIR" ]; then
    for lib_file in "$BUILD_LIB_DIR"/*.so*; do
        if [ -f "$lib_file" ] && [ ! -L "$lib_file" ]; then
            collect_libs "$lib_file"
        fi
    done
fi

# Copy all unique libraries
sort -u "$ALL_LIBS" | while read lib; do
    if [ -f "$lib" ]; then
        libname=$(basename "$lib")

        # Skip system libraries
        case "$libname" in
            libc.so*|libm.so*|libpthread.so*|libdl.so*|libgcc_s.so*|libstdc++.so*|ld-linux*)
                continue
                ;;
            *)
                if [ ! -f "$LIB_TEMP_DIR/$libname" ]; then
                    # Copy all required libraries including OpenCV and GStreamer
                    # Bundle from all paths (including /usr/lib, /lib/x86_64-linux-gnu, etc.)
                    echo "  Copying $libname from $lib..."
                    cp -L "$lib" "$LIB_TEMP_DIR/" 2>/dev/null || true
                fi
                ;;
        esac
    fi
done

# Copy symlinks and resolve them
# Multiple passes to handle nested symlinks
for pass in 1 2 3; do
    changed=false
    for lib in "$LIB_TEMP_DIR"/*.so*; do
        if [ -L "$lib" ] 2>/dev/null; then
            target=$(readlink -f "$lib")
            target_name=$(basename "$target")
            if [ -f "$target" ] && [ ! -f "$LIB_TEMP_DIR/$target_name" ]; then
                echo "  Resolving symlink: $(basename "$lib") -> $target_name"
                cp -L "$target" "$LIB_TEMP_DIR/" 2>/dev/null || true
                changed=true
            fi
        fi
    done
    [ "$changed" = false ] && break
done

# Final pass: ensure all symlinks point to files that exist
for lib in "$LIB_TEMP_DIR"/*.so*; do
    if [ -L "$lib" ] 2>/dev/null; then
        target=$(readlink -f "$lib")
        if [ ! -f "$target" ]; then
            # Try to find the target in the same directory
            target_name=$(basename "$target")
            if [ -f "$LIB_TEMP_DIR/$target_name" ]; then
                # Recreate symlink to point to local file
                rm -f "$lib"
                ln -sf "$target_name" "$lib" 2>/dev/null || true
            fi
        fi
    fi
done

echo "Libraries bundled successfully."
